# GC

GC 如何判断一个对象是否可以回收呢？我们可以使用以下算法分析

- 引用计数算法：给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。当引用计数为 0 时，对象就可以被回收。但是如果两个对象循环引用，二者的计数器永远不为 0，导致无法对他们进行回收。这是循环引用问题。

- 可达性分析算法：通过 GC Roots 作为起点进行搜索，能够达到的对象都是存活的，不可达的对象可以被回收。该算法可以避免循环引用问题，因此 Java 虚拟机主要通过这种算法来判断对象是否可被回收。

  在 JVM 里，GC Roots 是一些始终活跃的对象，它们不会被回收。常见的 GC Roots 包括：

  - 虚拟机栈（栈帧中的局部变量表）引用的对象：每个线程正在调用的方法里的局部变量，比如方法参数、局部变量。这些对象都存放在栈帧中，GC 是不会随便回收的，否则当前栈帧执行的函数可能会出问题。
  - 方法区中类的静态属性引用的对象，比如被 static 修饰的引用类型对象
  - 方法区中常量引用的对象，比如 final static 的常量引用对象
  - 本地方法栈中 JNI（Java Native Interface，Java 本地接口）引用的对象

### 引用类型

无论是通过引用计数算法判断对象的引用数量，还是通过可达性算法判断对象是否可达，判定对象是否可被回收都与引用有关

Java 具有四种强度不同的引用类型：

1. 强引用

   被强引用关联的对象不会被回收

   使用 new 创建的新对象是强引用

2. 软引用

   被软引用关联的对象只有在内存不够的情况下才会被回收

   使用 SoftReference 类来创建软引用

   ```java
   Object obj = new Object();
   SoftReference<Object> sf = new SoftReference<Object>(obj);
   obj = null;  // 使对象只被软引用关联
   ```

3. 弱引用

   被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前

   使用 WeakReference 类来实现弱引用

   ```java
   Object obj = new Object();
   WeakReference<Object> wf = new WeakReference<Object>(obj);
   obj = null;
   ```

4. 虚引用

   一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。设置虚引用的唯一目的就是能在这个对象被回收时收到一个系统通知

   使用 PhantomReference 来实现虚引用

   ```java
   Object obj = new Object();
   PhantomReference<Object> pf = new PhantomReference<Object>(obj);
   obj = null;
   ```

### 垃圾回收算法

GC 主要分为两个阶段

1. **判定对象是否存活**（对象存活性分析）
2. **真正回收垃圾对象**（垃圾收集算法）

通过对象存活判定算法判断之后，就可以进行垃圾回收操作了。常用的垃圾回收算法有：

1. 标记-清除（Mark-Sweep）：从 GC Roots 出发，标记所有可达对象记为存活对象，然后清除所有未标记的对象。这种算法标记和清除的效率都不高，而且会产生大量不连续的内存碎片，导致无法为大对象分配内存。
2. 标记-整理（Mark-Compact）：从 GC Roots 出发，标记所有可达对象记为存活对象，然后将存活对象压缩到一端，清理边界以外的内存。这样解决了空闲内存不连续问题，但是会移动对象需要更新引用，造成更大的开销。
3. 复制（Copying）：将内存分为两块，每次只用一块。GC 时把存活对象复制到另一块，并一次性清理原空间。这样会浪费一半空间。新生代 **Minor GC**（Eden + Survivor）就是它的典型应用。
4. 分代收集（Generational Collection）：不同对象存活时间不同，应采用不同的回收算法。一般将堆内存分为新生代和老年代，新生代使用复制算法，老年代使用标记 - 清除或者标记 - 整理算法。

### 垃圾回收器

垃圾回收算法是思想层面的，垃圾回收器是 JVM 提供的具体实现

> 垃圾回收器也分单线程和多线程，串行和并行
>
> 单线程和多线程是指垃圾收集器只能使用一个线程还是多个线程进行
>
> 串行是指垃圾收集器与用户程序交替执行，这会导致在执行垃圾回收的时候，用户程序需要停顿等待
>
> 并行是指垃圾回收期和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

**常见的垃圾回收器**

JVM 把堆分为新生代和老年代，不同收集器负责不同区域。

新生代收集器：

- Serial GC：他是单线程串行收集器，只会使用一个线程执行垃圾回收工作。它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。
- ParNew GC：是 Serial 的多线程版本，常与 CMS 搭配使用
- Parallel Scavenge GC：也是多线程收集器。它关注的是达到一个最大吞吐量（这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值）。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度可以提高用户的体验。而高吞吐量则可以高效的利用 CPU 时间，尽快完成程序的运算任务，适用于后台任务。

老年代收集器：

- Serial Old：是 Serial 的老年代版本，单线程
- Parallel Old：是 Parallel Scavenge 的老年代版本，多线程标记-整理，适合吞吐量优先的场景
- CMS：是一款并发收集器，基于标记-清除算法，可以与用户程序同时运行，降低停顿时间。但是吞吐量低，无法处理浮动垃圾，会导致出现空间碎片

跨代收集器：

- G1：它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。将整个堆划分为多个固定大小的 Region ，某些 Region 作为新生代，某些作为老年代，使得每个小空间可以单独进行垃圾回收。它会维护一个优先表，GC 时每次根据允许的收集时间，优先回收价值最大的 Region
- ZGC：它是一款适用于大内存低延迟服务的内存管理和回收。ZGC通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。
- Shenandoah：是一款低停顿并发垃圾收集器，主要使用标记-整理算法。但通过并发压缩技术，把最耗时的“整理内存”操作也变成并发执行，极大降低了 Stop-The-World 的时间。适用于对延迟敏感的系统。

**对比 G1 和 ZGC 垃圾回收器的性能**

很多低延迟高可用的 Java 服务的系统可用性经常受 GC 停顿（STW）的困扰。当 STW（Stop The World）时，所有应用服务线程停止活动，等待 GC 停顿结束。

G1 使用**标记-复制算法**，标记-复制算法的 GC 过程可以分为三个阶段：

- **标记阶段**，即从 GC Roots 集合开始，标记活跃对象
- **转移阶段**，即把活跃对象复制到新的内存地址上；
- **重定位阶段**，因为转移导致对象的地址发生了变化，在重定位阶段，所有指向对象旧地址的指针都要调整到对象新的地址上。

我们可以通过分析 G1 垃圾回收周期，来分析一下 G1 停顿停顿耗时的主要瓶颈。

G1 的混合回收过程主要分为标记阶段、清理阶段和复制阶段。

> G1 的回收模式：
>
> - Young GC（年轻代收集）：年轻代的 Region 空间不足时触发。只回收年轻代 Region
> - Mixed GC（混合收集）：当老年代使用率达到阈值（默认 45%）时，触发 Mixed GC。不仅收集 年轻代，还会回收部分老年代 Region
> - Full GC（整堆收集）

- 标记阶段
  - 初始标记阶段：标记 GC Roots 集合，该阶段是 STW 的，但因为 GC Roots 数量不多，通常该阶段耗时非常短
  - 并发标记阶段：通过可达性分析算法，从 GC Roots 开始找存活对象，这部分是并发执行的，不是 STW，没有停顿耗时
  - 再标记阶段：重新标记那些在并发标记阶段发生变化的对象。该阶段是STW的
- 清理阶段：清点出有存活对象的分区和没有存活对象的分区，该阶段不会清理垃圾对象，也不会执行存活对象的复制。该阶段是STW的
- 复制阶段：复制算法的转移阶段需要分配新内存和复制对象的成员变量。转移阶段是STW的，其中内存分配通常耗时非常短，但对象成员变量的复制耗时有可能较长，这是因为复制耗时与存活对象数量与对象复杂度成正比。对象越复杂，复制耗时越长。

**通过分析以上过程，转移阶段的 STW 需要处理所有的存活对象，这里停顿的时间是很长的**

ZGC 也使用标记-复制算法，但是 ZGC 在标记、转移和重定位阶段几乎都是并发的，只有初始标记，再标记，初始转移是 STW，而且初始标记和初始转移分别都只需要扫描所有GC Roots，其处理时间和GC Roots的数量成正比，一般情况耗时非常短。再标记阶段 STW 时间也很短，最多1ms，超过1ms则再次进入并发标记阶段。

因此，ZGC 更适合在低延时场景应用并且表现卓越。

#### 内存分配与回收策略

JVM 在进行 GC 时，并非每次都对堆内存区域一起回收，针对 HotSpot JVM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）

部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： 

- 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集
- 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集 
  - 目前，只有 CMS GC 会有单独收集老年代的行为
  - 很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收
- 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 
  - 目前只有 G1 GC 会有这种行为

整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾

> 对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就会触发一次 Minor GC。而 Full GC 相对复杂：
>
> - 调用 System.gc() 建议虚拟机执行 Full GC，但是但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存
> - 老年代空间不足。常见的场景为大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组

对于内存分配，大多数情况下对象在新生代 Eden 分配，当 Eden 区空间不够时，发起 Minor GC；当面临为大对象分配内存时，它会直接进入老年代，因为大对象需要连续的内存空间，经常会提前触发垃圾收集以此来获取足够的连续内存空间分配给大对象；长期存活的对象也会进入老年代。

我们常说的垃圾回收主要关注在堆里的对象，但其实方法区也会发生垃圾回收。这主要是对常量池的回收和对类的卸载。

- 回收常量池中的废弃常量：例如字符串常量池里 `"abc"` 如果没有任何地方再引用它，就可能被清理。
- 无用类的回收：
  - 该类的所有实例对象都已经被回收（堆中不存在该类的对象）
  - 加载该类的`ClassLoader`已被回收
  - 该类对应的`Class`对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法

