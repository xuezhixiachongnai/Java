# GC

GC 如何判断一个对象是否可以回收呢？我们可以分析以下算法

- 引用计数算法：给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1.当引用计数为 0 时，对象就可以被回收。但是如果两个对象循环引用，二者的计数器永远不为 0，导致无法对他们进行回收。这是循环引用问题。

- 可达性分析算法：通过 GC Roots 作为起点进行搜索，能够达到的对象都是存活的，不可达的对象可以被回收。该算法可以避免循环引用问题，因此 Java 虚拟机主要通过这种算法来判断对象是否可被回收。

  在 JVM 里，GC Roots 是一些始终活跃的对象，它们不会被回收。常见的 GC Roots 包括：

  - 虚拟机栈（栈帧中的局部变量表）引用的对象：每个线程正在调用的方法里的局部变量，比如方法参数、局部变量。这些对象都存放在栈帧中，GC 是不会随便回收的，否则当前栈帧执行的函数可能会出问题。
  - 方法区中类的静态属性引用的对象，比如被 static 修饰的引用类型对象
  - 方法区中常量引用的对象，比如 final static 的常量引用对象
  - 本地方法栈中 JNI（Java Native Interface，Java 本地接口）引用的对象

**引用类型**

无论是通过引用计算算法判断对象的引用数量，还是通过可达性算法判断对象是否可达，判定对象是否可被回收都与引用有关

Java 具有四种强度不同的引用类型：

1. 强引用

   被强引用关联的对象不会被回收

   使用 new 一个新对象的方式来创建强引用

2. 软引用

   被软引用关联的对象只有在内存不够的情况下才会被回收

   使用 SoftReference 类来创建软引用

   ```java
   Object obj = new Object();
   SoftReference<Object> sf = new SoftReference<Object>(obj);
   obj = null;  // 使对象只被软引用关联
   ```

3. 弱引用

   被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前

   使用 WeakReference 类来实现弱引用

   ```java
   Object obj = new Object();
   WeakReference<Object> wf = new WeakReference<Object>(obj);
   obj = null;
   ```

4. 虚引用

   一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。设置虚引用的唯一目的就是能在这个对象被回收时收到一个系统通知

   使用 PhantomReference 来实现虚引用

   ```java
   Object obj = new Object();
   PhantomReference<Object> pf = new PhantomReference<Object>(obj);
   obj = null;
   ```

### 垃圾回收算法

GC 主要分为两个阶段

1. **判定对象是否存活**（对象存活性分析）
2. **真正回收垃圾对象**（垃圾收集算法）

通过对象存活判定算法判断之后，就可以进行垃圾回收操作了。常用的垃圾回收算法有：

1. 标记-清除（Mark-Sweep）：从 GC Roots 出发，标记所有可达对象记为存活对象，然后清除所有未标记的对象。这种算法标记和清除的效率都不高，而且会产生大量不连续的内存碎片，导致无法为大对象分配内存。
2. 标记-整理（Mark-Compact）：从 GC Roots 出发，标记所有可达对象记为存活对象，然后将存活对象压缩到一端，清理边界以外的内存。这样解决了空闲内存不连续问题，但是会移动对象需要更新引用，造成更大的开销。
3. 复制（Copying）：将内存分为两块，每次只用一块。GC 时把存活对象复制到另一块，并一次性清理原空间。这样会浪费一半空间。新生代 **Minor GC**（Eden + Survivor）就是它的典型应用。
4. 分代收集（Generational Collection）：不同对象存活时间不同，应采用不同的回收算法。一般将堆内存分为新生代和老年代，新生代使用复制算法，老年代使用标记 - 清除或者标记 - 整理算法。

### 垃圾回收器

垃圾回收算法是思想层面的，垃圾回收器是 JVM 提供的具体实现

> 垃圾回收器也分单线程和多线程，串行和并行
>
> 单线程和多线程是指垃圾收集器只能使用一个线程还是多个线程进行
>
> 串行是指垃圾收集器与用户程序交替执行，这会导致在执行垃圾回收的时候，用户程序需要停顿等待
>
> 并行是指垃圾回收期和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

**常见的垃圾回收器**

JVM 把堆分为新生代和老年代，不同收集器负责不同区域。

新生代收集器：

- Serial GC：他是单线程串行收集器，只会使用一个线程执行垃圾回收工作。它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。
- ParNew GC：是 Serial 的多线程版本，常与 CMS 搭配使用
- Parallel Scavenge GC：也是多线程收集器。它关注的是达到一个最大吞吐量（这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值）。停顿时间越短就越适合需要与用户交互的程序，良好的响应速度可以提高用户的体验。而高吞吐量则可以高效的利用 CPU 时间，尽快完成程序的运算任务，适用于后台任务。

老年代收集器：

- Serial Old：是 Serial 的老年代版本，单线程
- Parallel Old：是 Parallel Scavenge 的老年代版本，多线程标记-整理，适合吞吐量优先的场景
- CMS：是一款并发收集器，基于标记-清除算法，可以与用户程序同时运行，降低停顿时间。但是吞吐量低，无法处理浮动垃圾，会导致出现空间碎片

跨代收集器：

- G1：把堆划分为多个固定大小的 Region ，某些 Region 作为新生代，某些作为老年代。GC 时从垃圾最多的 Region 清理，使用并发标记，可以预测最大停顿时间。适合于堆比较大、需要可控延迟的服务。
- ZGC：全堆并发回收，使用染色指针解决并发重定位的引用问题，不复制原内存，只转移访问逻辑，延迟极低。
- Shenandoah

#### 内存分配与回收策略

JVM 在进行 GC 时，并非每次都对堆内存区域一起回收，针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）

部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： 

- 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集
- 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集 
  - 目前，只有 CMS GC 会有单独收集老年代的行为
  - 很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收
- 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 
  - 目前只有 G1 GC 会有这种行为

整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾

> 对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就会触发一次 Minor GC。而 Full GC 相对复杂：
>
> - 调用 System.gc() 建议虚拟机执行 Full GC，但是但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存
> - 老年代空间不足。常见的场景为大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组
