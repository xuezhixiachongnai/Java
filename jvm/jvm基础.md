# JVM 基础

JVM 结构图：

```sh
         ┌───────────────────┐
         │   Class Loader    │ ← 加载字节码
         └────────┬──────────┘
                  │
        ┌─────────▼─────────┐
        │ Runtime Data Area  │ ← 内存区域
        │ ┌────────────────┐ │
        │ │ Method Area    │ │
        │ │ Heap           │ │
        │ │ JVM Stack      │ │
        │ │ Native Stack   │ │
        │ │ PC Register    │ │
        │ └────────────────┘ │
        └─────────┬─────────┘
                  │
        ┌─────────▼─────────┐
        │ Execution Engine   │ ← 解释器 + JIT + GC
        └─────────┬─────────┘
                  │
        ┌─────────▼─────────┐
        │ JNI & Native Libs  │ ← 调用本地方法
        └────────────────────┘
```

从图中可以看到，JVM主要由类加载器子系统、运行时数据区、执行引擎、本地方法接口、本地方法库组成。

## 类字节码

JVM 是运行类字节码的，java 代码需要被编译成字节码才能被 JVM 虚拟机读取执行。因此除了 java 外，只要是能编译成字节码的语言，都能够在 JVM 上运行，从而实现一次编译，到处运行的目的。

class 字节码文件本质上是一个以字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在 class 文件中。jvm 根据其特定的规则解析该二进制数据，从而得到相关信息。

以十六进制的形式打开生成的 class 文件是这样的：

```sh
# 在 win 上可以使用 Format-Hex Demo.class 命令
cafe babe 0000 0034 0013 0a00 0400 0f09
0003 0010 0700 1107 0012 0100 016d 0100
0149 0100 063c 696e 6974 3e01 0003 2829
5601 0004 436f 6465 0100 0f4c 696e 654e
756d 6265 7254 6162 6c65 0100 0369 6e63
0100 0328 2949 0100 0a53 6f75 7263 6546
696c 6501 0009 4d61 696e 2e6a 6176 610c
0007 0008 0c00 0500 0601 0010 636f 6d2f
7268 7974 686d 372f 4d61 696e 0100 106a
6176 612f 6c61 6e67 2f4f 626a 6563 7400
2100 0300 0400 0000 0100 0200 0500 0600
0000 0200 0100 0700 0800 0100 0900 0000
1d00 0100 0100 0000 052a b700 01b1 0000
0001 000a 0000 0006 0001 0000 0003 0001
000b 000c 0001 0009 0000 001f 0002 0001
0000 0007 2ab4 0002 0460 ac00 0000 0100
0a00 0000 0600 0100 0000 0800 0100 0d00
0000 0200 0e
```

运行以下命令反编译字节码

```sh
javac -c -p Demo.class
# -p  -private             显示所有类和成员
# -c                       对代码进行反汇编
```

得到 这种形式

```sh
public class Demo {
  public Demo();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #13                 // String Hello, World
       5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return
}
```

字节码本质上还是二进制数据，这些形式只是方便人阅读

## 字节码增强技术

可以动态的对运行中的程序做修改，也可以跟踪 JVM 运行中程序的状态。本质上是利用各种手段生成符合规范的字节码文件。如动态代理、AOP就与字节码增强密切相关

## 类加载机制

#### 类加载生命周期

Java 类加载的过程包括加载、验证、准备、解析、初始化五个阶段，其中验证、准备、解析这三个阶段统称为连接。这几个阶段除了解析，其他都是按顺序开始的。解析阶段在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定。

而**类加载的生命周期**还要包括使用、卸载。

- 加载：加载是类加载的第一个过程，在这个阶段 JVM 主要通过一个类的全限定名来获取其定义的二进制字节流，然后将这个字节流所代表的**静态存储结构**转化为方法区运行时数据结构，在 Java 堆中生成一个代表这个类的 Class 文件。

- 连接

  - 验证：这是连接阶段的第一步，其目的是为了确保 Class 文件字节流中的数据符合当前虚拟机的要求

  - 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。

    > 这一阶段只会为被 static 修饰的类变量分配内存，并不会为实例变量（没有 static 修饰的变量）分配内存。并且这里只会为变量设置数据类型默认的初始零值，而不是被 Java 代码中显示赋予的值。除了同时被 static final 修饰的变量。这种变量会在准备阶段赋予 Java 代码中显示赋予的值。

  - 解析：该阶段是将常量池内的符号引用替换为直接引用的过程

- 初始化：为类的静态变量赋予正确的初始值

- 使用：在堆区 new 出实例对象，访问方法区的数据结构

- 卸载：JVM 会在满足条件时卸载某个类，把它从方法区（元空间 Metaspace / 永久代 PermGen）中移除

> 在没有 new 出实例对象时，只有类中的 static 变量有给定的初始值

#### 类加载器，JVM 类加载机制

类加载器（ClassLoader）是 Java 中的一种机制，用于动态加载 Java 类，它的作用是将 Java 字节码文件（.class 文件）加载到 JVM 中

类加载器的层次

```sh
        BootStrapClassLoader
                /|\
                 |
           ExtClassLoader
                /|\
                 |
           AppClassLoader
                /|\
                 |
         UserClassLoader(自定义)
# 这里类加载器之间不是简单的继承的关系，而是 组合 + 委派
```

JVM 主要有三种类型的类加载器

- Bootstrap ClassLoader：启动类加载器，它使用C++实现(这里仅限于`Hotspot`，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，无法被 Java 程序直接引用。负责加载 JDK 核心类库，`rt.jar` 或 `java.base` 模块里的 `java.lang.*`、`java.util.*` 等
- Extension ClassLoader：扩展类加载器，负责加载`JAVA_HOME/lib/ext` 或 `java.ext.dirs` 指定目录下的类库，开发者可以直接使用
- Application ClassLoader：应用程序类加载器，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器

> sun.misc.Launcher$ExtClassLoader 和 sun.misc.Launcher$AppClassLoader 是 JDK 自带的类加载器

应用程序都是由这三种类加载器相互配合进行加载的，默认只能从本地文件系统中加载标准的 Java class 文件，例如要从数据库和网络中加载 class 文件，这时候就需要自己编写 ClassLoader

**JVM 类加载机制**

- 当一个类加载器加载某个 class 时，该 class 所依赖的和引用的其他 class 也将由该类加载器负责加载，除非是显示指定使用另一个类加载器
- 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
- 双亲委派机制

**双亲委派机制**

如果一个类加载器收到了一个加载类的请求，它首先不会自己去尝试加载，而是把它委托给父加载器，依次向上。因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

过程：

当 AppClassLoader 加载一个 Class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。当 ExtClassLoader 加载一个Class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。

如果 BootStrapClassLoader 加载失败，会使用 ExtClassLoader 来尝试加载；若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常ClassNotFoundException。

> 双亲委派机制的优点：
>
> - 避免类加载冲突：通过将类加载请求委托给父加载器，确保每个类的加载过程是有序和统一的 不同的类加载器加载相同名字的类时，父加载器会优先加载系统类，而子加载器则加载自定义类，避免了冲突
> - 提升系统的安全性：父加载器负责加载 JDK 和系统核心类库，从而避免应用程序加载恶意或篡改过的核心类，增强了系统的安全性 
> - 便于调试和排错：当出现类加载异常时，双亲委派机制的结构让问题定位变得更加清晰 如果某个类加载失败，可以逐层查看父类加载器的加载过程，定位问题的根源

> 类加载器子系统的工作过程：加载 → 链接（验证、准备、解析） → 初始化 → 交给执行引擎。
>  作用：负责把类加载进 JVM，通过双亲委派机制保证类的安全性，唯一性和隔离性，为模块化和热部署提供基础。

## JVM 内存结构

JVM 内存结构是对 Java 运行时程序的物理内存实现具体划分和管理，用来保证 Java 程序的正常执行。主要内容是内存分配、回收和管理

> 要区分**JVM** 和 **JMM** 的区别，JMM 是一种多线程并发访问内存的规则，用来解决多线程间的可见性、有序性和原子性

JVM 内存结构主要分为 **方法区（Method Area）**、**堆（Heap Area）**、**虚拟机栈（Java Virtual Machine Stacks）**、**程序计数器（Program Counter Register）**、**本地方法栈（Native Method Stack）**。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。

其中的一些数据区会随着虚拟机的启动而创建，随着虚拟机的退出而销毁，比如说：堆、方法区，他们就是线程共享的。另外一些则是于线程一一对应，这些会随着线程的开始和结束而创建销毁，比如说：程序计数器、虚拟机栈、本地方法栈，他们就是线程私有的。

#### 程序计数器

是每个线程的一块小内存空间，用来记录当前线程下一条要执行的字节码指令的地址（偏移量）。

作用：

- JVM 多线程是通过线程轮流切换、分配 CPU 时间片来实现的。当线程切换时，程序计数器保存了该线程执行到哪里，下次切回时能继续执行，而不是从头来过。
- JVM 字节码解释器就是依靠 PC 寄存器来顺序读取下一条指令

> **普通方法执行时**：PC 寄存器记录的是 **字节码指令地址（偏移量）**。
>
> **执行 Native 方法时**：PC 寄存器的值是 **未定义（Undefined）**，因为本地方法不是 JVM 字节码。
>
> 程序计数器占用内存极小，是 JVM 规范里 **唯一没有规定 `OutOfMemoryError` 情况的区域**（因为几乎不会出现内存不足）

#### 虚拟机栈

每个线程在创建时都会分配一个虚拟机栈，它是方法执行时的内存模型，即方法调用过程中的内存结构。

JVM 对栈的直接操作只有两个，对栈帧的压栈和出栈，遵循先进后出的原则

在一个线程中，一个时间点上只会存在一个活动的栈帧（栈顶栈帧），即当前线程正在执行的方法。如果在该方法中调用了其他方法，该方法的栈帧会被创建并压入栈顶，成为新的当前栈帧。上一个栈顶栈帧则会停止执行。如果当前方法返回时，当前栈帧会将此方法的结果回传给上一个栈帧，接着虚拟机会丢弃当前栈帧，使得上一个栈帧重新回到栈顶。

> Java 方法有两种返回函数的方式，**一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出**
>
> 可以结合方法栈来考虑递归

栈是由**栈帧**组成的。栈帧是一块内存区域，它包含着各种数据信息：

- 局部变量表：储存方法的参数、方法中声明的局部变量
- 操作数栈：用于保存计算过程的中间结果，以及作为字节码指令的操作数
- 动态链接：保存指向运行时常量池中该方法引用的指针，用于方法调用时解析
- 方法返回地址：保存方法执行完后，应该返回到调用者的字节码指令地址

> 可以通过参数`-Xss`来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度

#### 本地方法栈

> 本地方法接口：简单的讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口
>
> 为什么要使用本地方法：
>
> - 与 Java 环境交互
> - 与操作系统交互

虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。本地方法栈是线程私有的

> 在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一
>
> 栈是有大小的，无论是虚拟机栈还是本地方法栈都会出现**异常情况**
>
> - 如果线程请求的栈深度超过了允许的范围，会抛出：**`StackOverflowError`**
>
> - 如果本地方法栈无法申请到足够内存，会抛出：**`OutOfMemoryError`**

#### 堆

对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存中唯一存放的就是对象实例。为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分为三块区域

> Java 堆大小在 JVM 启动的时候就确定了，可以通过`-Xmx` 和 `-Xms` 来设定，通常将这两个值设定为相同大小
>
> - `-Xms` 用来表示堆的起始内存
> - `-Xmx` 用来表示堆的最大内存
>
> 如果堆的内存大小超过 `-Xmx` 设定的最大内存， 就会抛出 `OutOfMemoryError` 异常。

**新生代**

存放新对象和没有达到一定年龄的对象

新生代被分为三部分，**Eden区** 和 **Survivor区**，Survivor 区由 **From Survivor** 和 **To Survivor** 组成，默认比例是 8:1:1。

大多数创建的新对象都会存放在 Eden 中，当 Eden 空间不足时会执行 GC。在执行 GC 垃圾回收之后，幸存者对象会被移动到一个幸存者空间。在幸存者空间同样会经历 GC，本轮的幸存者又会移动到另一个幸存者空间中经过多次 GC 循环幸存后存活下来的对象被移到老年区。

**老年代**

存放被长期使用的对象，旧一代内存中经过多轮 GC 后仍存活的对象。当老年代内存满了之后，会执行 GC

大对象直接存入老年代，防止大对象来回在幸存区拷贝

> 堆内存与栈内存的对比
>
> - 堆内存主要储存对象实例、数组、类成员变量等；栈内存主要存储方法调用、局部变量、参数、返回地址等
> - 堆可以动态分配内存，大小可调，内存使用垃圾回收器管理；栈内存自动分配，大小固定，每个线程都有自己的栈
> - 堆由垃圾回收器管理，生命周期较长，取决于对象引用情况；栈中的局部变量和方法栈帧的生命周期仅限于方法调用期间
> - 堆访问较慢，涉及到堆内存管理和垃圾回收；栈访问快速，栈帧的创建与销毁由系统自动管理
> - 堆线程共享；栈是每个线程都有自己的栈
> - 堆需要垃圾回收器定期清理无用对象；栈不需要垃圾回收，方法结束时自动销毁栈帧

#### 方法区

方法区是 JVM 内存中 **专门存放类元数据、静态变量和常量池**的区域。方法区与堆不同，存对象实例的地方在堆，方法区存类信息和静态数据。也有人称方法区为 **永久代（PermGen，JDK 8 前）** 或 **元空间（Metaspace，JDK 8+）**。

方法区属于线程共享的内存区域，多个线程可以访问同一个类的信息。

方法区内存不是永久不变的，当某个类的 ClassLoader 被回收且该类的实例都不存在时，该类的信息可以被 GC 卸载。

### JMM

每个线程都有自己的工作内存（栈/寄存器）

当线程访问一个共享变量（在堆或方法去）时，会先从主内存读取到自己的工作内存，形成副本

当线程修改副本后，它不会立刻把修改后的变量写回主存

其他线程访问同一变量时，仍然会读到旧的值

这就是线程之间对共享变量的修改不可立即看到，导致**内存可见性问题**

多个线程同时操纵共享变量，单个操作不是原子操作（例如`x++`的字节码其实有三步 **读-改-写**），当执行修改的线程还没有执行完，cpu 就切换到其他线程执行，导致其读取的变量仍是没有修改的变量。这就是**原子性问题**。

编译器或 CPU 为了优化，会对指令进行 **重排序**，导致线程看到的执行顺序与代码顺序不一致，这就是**有序性问题**

JMM 的引入就是为了解决这些问题。

**可见性**

1. 使用`volatile` 关键字
   - 保证**读写直接操作主内存**，线程不会使用工作内存的副本。

2. 使用`synchronized` 同步块
   - 进入同步块时，**刷新工作内存**，读取主内存最新值。
   - 退出同步块时，将修改写回主内存，保证其他线程可见。
   - 原理：锁会产生**内存屏障**（Memory Barrier），强制工作内存和主内存同步。

**原子性**

1. 使用`synchronized` 锁
   - 同步块保证同一时间只有一个线程访问共享资源，操作不会被打断。

2. 使用原子类（`AtomicInteger` 等）
   - 利用 **CPU 原子指令（CAS）** 实现无锁的原子操作。
   - JMM 保证对原子类的操作对其他线程可见，并且操作不会被中断。

**有序性**

1. 使用`volatile`
   - 读写 volatile 变量前后会产生**内存屏障**，禁止重排序。
   - 保证 **happens-before** 规则成立：写入 volatile 的操作，先于后续对该变量的读取操作被看到。

2. 使用`synchronized`
   - 锁操作会在进入和退出时产生**内存屏障**：
     - 进入同步块时，线程会从主内存刷新变量到工作内存。
     - 退出同步块时，线程会将修改写回主内存。
   - 内存屏障同时保证了顺序执行，避免重排破坏逻辑
