# JVM 基础

## 类字节码

JVM 是来运行类字节码的，java 代码需要被编译成类字节码才能被 JVM 虚拟机读取执行。因此除了 java 外，只要是能编译成字节码的语言，都能够在 JVM 上运行，从而实现一次编译，到处运行的目的。

class 字节码文件本质上是一个以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。jvm 根据其特定的规则解析该二进制数据，从而得到相关信息。

以文本的形式打开生成的 class 文件是这样的：

```sh
# 在 win 上可以使用 Format-Hex Demo.class 命令
cafe babe 0000 0034 0013 0a00 0400 0f09
0003 0010 0700 1107 0012 0100 016d 0100
0149 0100 063c 696e 6974 3e01 0003 2829
5601 0004 436f 6465 0100 0f4c 696e 654e
756d 6265 7254 6162 6c65 0100 0369 6e63
0100 0328 2949 0100 0a53 6f75 7263 6546
696c 6501 0009 4d61 696e 2e6a 6176 610c
0007 0008 0c00 0500 0601 0010 636f 6d2f
7268 7974 686d 372f 4d61 696e 0100 106a
6176 612f 6c61 6e67 2f4f 626a 6563 7400
2100 0300 0400 0000 0100 0200 0500 0600
0000 0200 0100 0700 0800 0100 0900 0000
1d00 0100 0100 0000 052a b700 01b1 0000
0001 000a 0000 0006 0001 0000 0003 0001
000b 000c 0001 0009 0000 001f 0002 0001
0000 0007 2ab4 0002 0460 ac00 0000 0100
0a00 0000 0600 0100 0000 0800 0100 0d00
0000 0200 0e
```

运行以下命令

```sh
javac -c -p Demo.class
# -p  -private             显示所有类和成员
# -c                       对代码进行反汇编
```

得到 

```sh
public class Demo {
  public Demo();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #13                 // String Hello, World
       5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return
}
```

字节码本质上还是二进制数据，这些只是方便人读的形式

## 字节码增强技术

可以动态的对运行中的程序做修改，也可以跟踪 JVM 运行中程序的状态。本质上是利用各种手段生成符合规范的字节码文件。如动态代理、AOP就与字节码增强密切相关

## 类加载机制

Java 类加载机制就是 JVM 按照 加载 → 验证 → 准备 → 解析 → 初始化的顺序，把字节码变成内存里的 `Class` 对象，并通过双亲委派模型管理类的加载过程。

#### 类加载生命周期

```sh
加载 → 连接（验证、准备、解析） → 初始化
```

这几个阶段除了解析，其他都是按顺序开始的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定。

- 加载：加载是类加载的第一个过程，在这个阶段 JVM 主要通过一个类的全限定名来获取其定义的二进制字节流，然后将这个字节流所代表的**静态存储结构**转化为方法区运行时数据结构，在 Java 堆中生成一个代表这个类的 Class 文件。

- 连接

  - 验证：这是连接阶段的第一步，其目的是为了确保 Class 文件字节流中的数据符合当前虚拟机的要求

  - 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。

    > 这一阶段只会为被 static 修饰的类变量分配内存，并不会为实例变量（没有 static 修饰的变量）分配内存。并且这里只会为变量设置数据类型默认的初始零值，而不是被 Java 代码中显示赋予的值。除了同时被 static final 修饰的变量。这种变量会在准备阶段赋予 Java 代码中显示赋予的值。

  - 解析：该阶段是将常量池内的符号引用替换为直接引用的过程

- 初始化：为类的静态变量赋予正确的初始值

#### 类加载器

Java 类加载器是 JVM 里负责把字节码加载到内存，并创建 Class 对象的组件，它是类加载机制的核心组件之一。

类加载器的层次

```sh
        BootStrapClassLoader
                /|\
                 |
           ExtClassLoader
                /|\
                 |
           AppClassLoader
                /|\
                 |
         UserClassLoader(自定义)
# 这里类加载器之间不是简单的继承的关系，而是 组合 + 委派
```

JVM 主要有三种类型的类加载器

- Bootstrap ClassLoader：启动类加载器，它使用C++实现(这里仅限于`Hotspot`，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，无法被 Java 程序直接引用。负责加载 JDK 核心类库，`rt.jar` 或 `java.base` 模块里的 `java.lang.*`、`java.util.*` 等
- Extension ClassLoader：扩展类加载器，负责加载`JAVA_HOME/lib/ext` 或 `java.ext.dirs` 指定目录下的类库，开发者可以直接使用
- Application ClassLoader：应用程序类加载器，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器

> sun.misc.Launcher$ExtClassLoader 和 sun.misc.Launcher$AppClassLoader 是 JDK 自带的类加载器

应用程序都是由这三种类加载器相互配合进行加载的，默认只能从本地文件系统中加载标准的 Java Class 文件，例如要从数据库和网络中加载 Class 文件，这时候就需要自己编写 ClassLoader

**JVM 类加载机制**

- 当一个类加载器加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将由该类加载器负责加载，除非是显示指定使用另一个类加载器
- 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
- 双亲委派机制

**双亲委派机制**

如果一个类加载器收到了一个加载类的请求，它首先不会自己去尝试加载，而是把它委托给父加载器，依次向上。因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

过程：

当 AppClassLoader 加载一个 Class 时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器 ExtClassLoader 去完成。当 ExtClassLoader 加载一个Class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给 BootStrapClassLoader 去完成。

如果 BootStrapClassLoader 加载失败，会使用 ExtClassLoader 来尝试加载；若 ExtClassLoader 也加载失败，则会使用 AppClassLoader 来加载，如果 AppClassLoader 也加载失败，则会报出异常ClassNotFoundException。

> 双亲委派机制的优点：

#### 触发类初始化的时机

- new 一个实例
- 调用某个类或接口的静态变量或对该静态变量赋值或调用类的静态方法
- 反射

## JVM 内存结构

JVM 内存结构是对 Java 运行时程序的物理内存实现具体划分和管理，用来保证 Java 程序的正常执行。主要内容是内存分配、回收和管理

> 要区分**JVM** 和 **JMM** 的区别，JMM 是一种多线程并发访问内存的规则，用来解决多线程间的可见性、有序性和原子性

JVM 内存结构主要分为 **方法区（Method Area）**、**堆（Heap Area）**、**虚拟机栈（Java Virtual Machine Stacks）**、**程序计数器（Program Counter Register）**、**本地方法栈（Native Method Stack）**。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。

其中的一些数据区会随着虚拟机的启动而创建，随着虚拟机的退出而销毁，比如说：堆、方法区，他们就是线程共享的。另外一些则是于线程一一对应，这些会随着线程的开始和结束而创建销毁，比如说：程序计数器、虚拟机栈、本地方法栈，他们就是线程私有的。

#### 程序计数器

是每个线程的一块小内存空间，用来记录当前线程下一条要执行的字节码指令的地址（偏移量）。

作用：

- JVM 多线程是通过线程轮流切换、分配 CPU 时间片来实现的。当线程切换时，程序计数器保存了该线程执行到哪里，下次切回时能继续执行，而不是从头来过。
- JVM 字节码解释器就是依靠 PC 寄存器来顺序读取下一条指令

> **普通方法执行时**：PC 寄存器记录的是 **字节码指令地址（偏移量）**。
>
> **执行 Native 方法时**：PC 寄存器的值是 **未定义（Undefined）**，因为本地方法不是 JVM 字节码。
>
> 程序计数器占用内存极小，是 JVM 规范里 **唯一没有规定 `OutOfMemoryError` 情况的区域**（因为几乎不会出现内存不足）

#### 虚拟机栈

每个线程在创建时都会分配一个虚拟机栈，它是方法执行时的内存模型，即方法调用过程中的内存结构。

JVM 对栈的直接操作只有两个，对栈帧的压栈和出栈，遵循先进后出的原则

在一个线程中，一个时间点上只会存在一个活动的栈帧（栈顶栈帧），即当前线程正在执行的方法。如果在该方法中调用了其他方法，该方法的栈帧会被创建并压入栈顶，成为新的当前栈帧。上一个栈顶栈帧则会停止执行。如果当前方法返回时，当前栈帧会将此方法的结果回传给上一个栈帧，接着虚拟机会丢弃当前栈帧，使得上一个栈帧重新回到栈顶。

> Java 方法有两种返回函数的方式，**一种是正常的函数返回，使用 return 指令，另一种是抛出异常，不管用哪种方式，都会导致栈帧被弹出**
>
> 可以结合方法栈来考虑递归

栈是由**栈帧**组成的。栈帧是一块内存区域，它包含着各种数据信息：

- 局部变量表：储存方法的参数、方法中声明的局部变量
- 操作数栈：用于保存计算过程的中间结果，以及作为字节码指令的操作数
- 动态链接：保存指向运行时常量池中该方法引用的指针，用于方法调用时解析
- 方法返回地址：保存方法执行完后，应该返回到调用者的字节码指令地址

> 可以通过参数`-Xss`来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度

#### 本地方法栈

是一个调用本地方法（不是 Java 实现的方法）的接口

当线程调用本地方法时，JVM 就会切换到本地方法栈来执行。本地方法栈会为本地方法分配空间，保存其执行的局部变量、操作数信息等

**异常情况**

- 如果线程请求的栈深度超过了允许的范围，会抛出：**`StackOverflowError`**

- 如果本地方法栈无法申请到足够内存，会抛出：**`OutOfMemoryError`**

> 在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一

#### 堆

对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存中唯一存放的就是对象实例。为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分为三块区域

> Java 堆大小在 JVM 启动的时候就确定了，可以通过`-Xmx` 和 `-Xms` 来设定，通常将这两个值设定为相同大小
>
> - `-Xms` 用来表示堆的起始内存
> - `-Xmx` 用来表示堆的最大内存
>
> 如果堆的内存大小超过 `-Xmx` 设定的最大内存， 就会抛出 `OutOfMemoryError` 异常。

**新生代**

存放新对象和没有达到一定年龄的对象

新生代被分为三部分，**Eden区** 和 **Survivor区**，Survivor 区由 **From Survivor** 和 **To Survivor** 组成，默认比例是 8:1:1。

大多数创建的新对象都会存放在 Eden 中，当 Eden 空间不足时会执行 GC。在执行 GC 垃圾回收之后，幸存者对象会被移动到一个幸存者空间。在幸存者空间同样会经历 GC，本轮的幸存者又会移动到另一个幸存者空间中经过多次 GC 循环幸存后存活下来的对象被移到老年区。

**老年代**

存放被长期使用的对象，旧一代内存中经过多轮 GC 后仍存活的对象。当老年代内存满了之后，会执行 GC

大对象直接存入老年代，防止大对象来回在幸存区拷贝

**元空间**

在 JDK 1.8 之前叫永久代，用啦存放一些方法操作中的临时对象。JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存。他是方法区的一种实现

#### 方法区

是与堆一样是所有线程共享的内存区域，用来存放类的信息，包括类的方法信息，字段信息相关父类以及接口信息。**运行时常量池**是方法区的一部分，它是用来存储 Class 文件中常量池内的信息，包括各种字面量和符号引用。

### JMM

