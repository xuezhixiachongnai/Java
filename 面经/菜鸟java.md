# 菜鸟 Java

##### 1.介绍 Java 有几种集合类

Java 集合类有两个顶级接口，分别是 Collection 和 Map

Collection 下又包括 List、Queue、Set

List 接口的主要实现类有 ArrayList、LinkedList

Queue 主要的实现类有 LinkedList

Set 主要的实现类有 HashSet、TreeSet

Map 接口的主要实现类有 HashMap、TreeMap

以上这些都不是线程安全的集合类，常用的线程安全的集合类有

ConcorrentHashMap、ArrayBlockingQueue、LinkedBlockingQueue

##### 2.具体有几种 list?

`ArrayList`、`LinkedList`、ArrayBlockingQueue、LinkedBlockingQueue

##### 3.如果给你一个对象，ArrayList你有几种排序方式?

可以给对象实现 Comparable 接口，然后使用 Collections.sort() 排序

也可以直接向该方法传入一个 自定义的 Comparator 来实现排序

调用 List 接口的 sort() 方法也可以实现排序

##### 4.那你刚刚提到了Comparable 和 Comparator 这两种方式，你知道这两种方式有什么区别吗?

Comparable 是通过类实现该接口的 compareTo 方法让类具备排序的能力

Comparator 是是一个函数式接口，不需要类实现，直接作为参数传递

##### 5.HashMap 的数据结构

HashMap 使用数组来存储 key-value 对

当发生哈希冲突时，对应数组位置处会通过链表来解决该冲突

当数组长度大于 64，链表长度大于 8 时，链表将会转换为红黑树以提升效率

##### 6.那它是线程安全的吗?

不是

##### 7.如果要实现 HashMap 的线程安全，可以用什么样的方式呢?

可以使用 Collections.synchronizeMap 将一个 HashMap 包装为线程安全的 Map，该方法是通过在 HashMap 的方法上加 synchronized 实现的

使用 ConcurrentHashMap 代替 HashMap

##### 8.你刚才说 ConcurrentHashMap 是可以保证线程安全的，那它是如何保证线程安全的?

在 jdk 1.7 时，是通过分段锁的方式，每一段维护一部分数据，并有自己的锁，这一部分是线程安全的，读操作无锁，写操作只会锁住对应分段的数据，提高了并发效率

在 jdk 1.8 时，通过 CAS + synchronized 来实现线程安全的。

它的底层数据结构和 HashMap 类似，只不过在写操作时，当前桶位置没有数据的化通过 CAS 机制来写入数据，如果桶非空，则使用 synchronized 锁定桶的头节点插入数据

##### 9.那你有了解过什么是 CAS 吗?

是一种无锁的原子操作，是乐观锁的一种实现方式

大致原理是

它会将需要操作的变量从内存中读取到线程的工作空间中，操作变量的时候先将工作空间的变量值和内存中的值比较，如果两只相等，则将工作空间的值修改，然后写入主内存，如果不相等则失败

##### 10.CAS 会导致什么问题呢?

它会导致 ABA 问题，这个问题大致是当一个线程将值修改了，另一个线程将值修改成原来的值，而第三个线程在操作对比时以为值没有发生变化。导致出错

解决这个问题可以加上一个版本号，当修改值的时候把版本号一并修改，在对比的时候发现版本号不同即认为该值已经被修改

##### 11.你知道 Redis 它为什么会那么快吗?

redis 的所有数据都存在内存里，读写快

redis 在存数据时使用了多种优化过的底层数据结构，这些结构使得在内存中运算时效率极高

redis 使用单线程、IO 多路复用机制，这使得它避免了多线程的上下文切换和锁的开销，使得它性能更好

##### 12.你刚刚说到它是基于内存的这个操作，那我直接在内存中创建一个 HashMap 不可以吗?

首先 HashMap 不是线程安全的，它不能应对高并发场景

其次，redis 存储数据的结构也不单是 key-value，它有很丰富的数据结构

然后是 redis 可以满足分布式，可以允许多个不同的服务访问

##### 13.他又提示一下，没说全，那如果我的服务突然宕机了，需要重重启。那会会怎么样?如果我用 HashMap 的话。然后我提了持久化这样

redis 支持内存数据持久化，包括 rpb 和 aof 的持久化机制

##### 14.你刚刚说说 Redis 它是单线程的，那它为什么设计成单线程呢?以及它为什么单线程还能这么快呢?有有了解过吗?

多线程需要考虑加锁、死锁等问题，会增加实现的复杂度，单线程使用 IO 多路复用，不需要加锁，也是线程安全的

单线程模式下，命令是串行执行的，不会被其他命令打断，保证了操作的原子性，也让 redis 的性能十分稳定 

它的数据都存在内存中，不需要 IO 操作

它优化了底层的数据结构，时操作数据时的效率非常高

使用 IO 多路复用技术，单线程也能处理大量线程，同时单线程也避免了额外的线程开销

##### 15.你的项目中用到 Redis 来做库存扣减，那你是怎么保证 Redis 和 MySQL 数据库的数据的一致性?

常见的策略有

一、现在 redis 扣减库存，成功之后通过消息队列异步通知 mysql 写入 数据库

二、先在 mysql 中更新库存，成功之后在操作 redis 缓存

三、使用延迟双删策略，先更新数据库，再删除缓存，过一段时间后再删一次缓存

四、使用定时校对任务，所有请求只操作 redis，然后定时将 redis 数据异步更新给 mysql

##### 16.你怎么解决的大key问题

大 key 问题是指某个 key 对应的 value 特别大，或者是单个 key 对应的 元素太多

首先是排查大 key

可以通过

命令行排查

`MEMORY USAGE key` 查看单个 key 占用多少字节。

`MEMORY STATS` 查看整体内存情况。

`SCAN` 遍历 keys

也可以使用第三方工具排查

redis-cli --bigkeys
redis-cli --memkeys
redis-cli --hotkeys

##### 17.讲-下 Redis 集群模式有多少种?

常见的有主从复制、哨兵模式、Cluster 模式、代理模式、混合模式

##### 18.如果你负责的这块业务，它的 QPS 突然提升了 100 倍，这种情况下你会怎么去处理它?

先排查原因，然后根据原因进行限流、熔断、降级等操作

##### 19.那你知道限流、降级，还有熔断，这三个场景区别是什么?

限流是通过控制进入系统的请求速率来避免流量过大将系统打垮

降级是在系统压力过大或部分功能故障时，主动关闭或简化某些非核心功能以保证核心功能正常运行

熔断是当下游服务出现大量错误或超时时，**短时间内不再调用下游服务**，直接快速失败，避免资源浪费和雪崩效应

##### 20.假设 Redis 它被打满，还能够继续用吗?

这取决于 `maxmemory-policy` 配置

如果没有内存大小限制（即：`maxmemory` 未配置），一旦机器物理内存被 redis 占满，机会触发 OOM，导致 redis 进程被系统删除

如果 `maxmemory-policy` 配置了，将有一下内存淘汰策略

常见的内存淘汰策略有

**noeviction**（默认）

- 内存满了就报错，不再接收写请求（只读请求还可以）。

**volatile-lru**

- 从设置了过期时间的 key 中，淘汰最近最少使用的 key。

**volatile-ttl**

- 从设置了过期时间的 key 中，淘汰 TTL 最小的（即最早要过期的）。

**volatile-random**

- 从设置了过期时间的 key 中，随机淘汰。

**allkeys-lru**

- 从所有 key 中，淘汰最近最少使用的 key（推荐用于缓存）。

**allkeys-random**

- 从所有 key 中，随机淘汰。

##### 21.Redis 的过期策略，有了解吗?

redis 可以为 key 设置 ttl 过期时间，到期后 key 就会被删除

但是 redis 并不是简单的定时删除，而是用了两种策略结合

一个是惰性删除，当访问一个 key 时，redis 会先检查它是否过期，如果已过期，就会立刻删除该 key-value，并且不会返回值，如果没过期正常返回

另一个是定期删除。redis 会周期性的抽样一些设置了过期时间的 key，检查它是否过期，如果过期了就会被删除。这种方法它不会扫描所有 key，而是随机采样限时循环。

如果 redis 内存满了，即使 key 没过期也必须删除，这是内存淘汰策略。

##### 22.最后问一个算法题,说思路，一个无序的整数数组，然后要求返回一个同样长度的数组。返回的数组每一位，它代表的是我之前给你的那个数组中的每一位的下一位比它更大的数的下标，如果后面没有比它更大的数的话，就用-1来代替。再问空间和时间复杂度反问表现，说我实际解决问题能力有待提高，QPS那个应该先考虑是不是恶意请求什么的，没考虑到呢