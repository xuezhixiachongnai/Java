# 京东后端面经

##### 1.Java 里常用的集合有哪些?

`ArrayList`、`LinkedList`、`HashMap`、`HashSet`、`TreeSet`、`TreeMap`、`ConcurrentHashMap`

##### 2.数组的底层原理是啥?

是一块计算机分配的连续的内存空间，用来存储相同的数据类型

##### 3.ArrayList 是怎么扩容的?

它是由一块动态数组存储数据的，默认大小是 10，当内存不够就会将其扩大到原来内存的 1.5 倍

##### 4.ArrayList 在哪些场景下不太好用?

在频繁做插入删除的情况下，它需要移动大量元素，不适合

它是不是线程安全的吗，因此在并发访问修改数据的情况下也不适合

##### 5.HashMap 是怎么解决哈希冲突的?

它的底层是通过数组在存放键值对数据的，当发生哈希冲突时，发生冲突的位置就会使用链表来存放数据

##### 6.讲讲快速排序。



##### 7.讲讲堆排序。



#####  8.Java 里的`sort` 方法用的是什么排序算法?



#####  9.`final` 关键字有什么用?

修饰字段，表示该字段是一个常量，不可修改

基本类型的字段值不可被修改

引用类型的引用不可被修改

修饰方法，表示该方法不可以被重写

修饰类，表示该类不可继承

##### 10.Java 实现多线程有几种方式?  *

> 创建线程的方式

通过继承 `Thread` 类

通过实现 `Runnable` 接口

通过实现 `Callable` 接口

使用线程池

##### 11.线程池的主要参数有哪些?

核心线程数

最大线程数

空闲线程存活时间

时间单位

任务队列

线程工厂

拒绝策列

##### 12.线程池的拒绝策略有哪些?

JDK 默认了 4 种拒绝策略

- 默认直接抛出 `RejectedExecutionException` 异常

- 把任务交给提交任务的线程处理
- 直接丢弃新提交的任务
- 丢弃队列中最早的一个任务，尝试执行新任务

##### 13.除了线程池，还接触过其他开启多线程的方式吗? *



##### 14.`synchronized` 和`ReentrantLock`有什么区别?

是 java 的关键字，是 JVM 层面支持的内置锁

它不需要手动解锁

是非公平锁

是 `java.util.concurrent.locks` 包下的类，是 JDK 提供的 **显式锁**，比 `synchronized` 更灵活

需要手动获取和释放锁

支持公平和非公平锁

##### 15.介绍-下`ReentrantLock`底层的 AQS. *

它是一个构建锁和同步器的框架

核心思想是内部维护一个 `int` 类型的 `status` 的状态，表示是否加锁，重入次数等

还维护了一个先进先出的队列，用于管理获取不到锁的线程

##### 16.CAS 底层用的是什么技术? *

CAS 是一种原子操作，是通过 CPU 提供的原子指令来实现的 CAS 的

##### 17.听说过无锁吗? *

就是不是通过互斥锁，而是通过原子操作来保证多线程下的数据安全

比如乐观锁就是一种无锁

##### 18.`ThreadLocal` 用过吗?

用过，常用于保存线程上线文的信息，用于实现线程内的变量共享

##### 19.用`ThreadLocal` 的时候要注意什么问题?

`ThreadLocalMap` 存储数据类似于 Map，通常存储一个 key-value，但是它的 key 是弱引用，可能被 GC 回收

但是 value 是强引用，如果不清理，value 会一直存在，导致内存泄漏。

在线程池复用的时候，它里面存储的数据更因该注意清理，否则在下次复用该线程时拿到上次个操作存储的数据

##### 20.怎么保证 `ThreadLocal` 的 `remove`方法一定会被执行?

使用 `try-finall` 

##### 21.调用`remove`方法的目的是什么?

会清除 `ThreadLocal` 中存放的键值对

##### 22.数据库的事务隔离级别有哪些?

读未提交

读已提交

可重复读

可串行化

##### 23.MySQL 默认的事务隔离级别是哪个?

可重复读

##### 24.MySQL 是怎么解决不可重复读问题的?

不可重复度是在一个事务里，前后两次读取的数据不一致

mysql 默认就是不可重复读的隔离级别，它是通过 MVCC 实现的

实现 MVCC 有两个关键机制

一是每行数据都会有两个隐藏字段，一个是最近修改行的事务 id，另一个是指向 undo_log 日志的指针

二是当事务开始，会生成一个读视图，该视图记录了事务提交状况的 ID，SELECT 查询时，就会与该视图对比判断，最近修改行事务的 id 是否在可见范围内，如果可见直接返回数据，不可见则通过 undo_log 查找旧版数据