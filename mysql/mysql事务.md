# MySQL 事务

事务是数据库中最小的逻辑执行单元，由一组 SQL 语句组成，要么全部成功，要么全部失败。

## 事务的四大特性（ACID）

- 原子性：一个事务中的所有操作要么全部执行成功，要么全部失败回滚。

- 一致性：事务执行前后数据库的完整性约束没有被破坏。

  > 一个事务将一笔钱从 A 转移到 B，无论事务失败还是成功，A 和 B 的总金额不变

- 隔离性：每个事务的操作对其他事务是透明的，一个事务的中间结果对其他事务是不可见的。

- 持久性：事务完成后，对数据库的修改将永远保存在数据库中。

## 事务的隔离级别

- 读未提交：最低的隔离级别，事务中的修改，即使没有提交也可以被其他事务读取。
- 读已提交：保证事务读取的数据都是已经提交的。
- 可重复读：保证同一个事务中，多次读取的同一条数据是一致的。MySQL 默认的事务隔离级别。
- 串行化：最高的隔离级别，将所有的事务串行执行，保证了数据的完全隔离。

> - 读未提交会引发脏读问题，即读取到未提交的数据可能导致数据不一样
> - 读已提交存在不可重复读问题，即同一个事务中，不同时间读取的数据可能不一样，因为中途有其他事务修改并提交了该记录
> - 可重复读存在幻读问题，即在一个事务中，同一范围两次查询到的数据条数不一样
> - 串行化避免了上述所有问题，但并发性最差，可能导致大量的锁等待和死锁

## 锁的分类

### 行锁

对表中某一行数据上锁，持有锁的事务可以修改该行数据。锁的粒度最细，对并发性能影响最小。

```sql
# 会话1
BEGIN;
# SELECT ... FOR UPDATE 加排他锁，别人不能修改也不能读取
# SELECT ... LOCK IN SHARE MODE 加共享锁，允许读但不允许写
SELECT * FROM orders WHERE id = 1 FROM UPDATE; 
UPDATE orders SET amount = amount + 1 WHERE id = 1;
COMMIT;

# 会话2
BEGIN;
...
```

> 在mysql中，事务默认是自动提交的，因此，要想将多条语句放在一个事务中就需要手动开启事务：
>
> ```sql
> BEGIN; # 手动开启事务
> ...
> COMMIT # 提交事务
> ```

### 表锁

对整张表上锁，持有锁的事务可以操作该表的任意数据。锁的粒度最大，对并发性能影响最大。

```sql
BEGIN;
# LOCK TABLES table_name lock_type 给表加锁
# WRITE(排他锁) 加写锁 READ(共享锁) 加读锁
LOCK TABLES orders WRITE;
UPDATE orders SET amount = amount + 1;
COMMIT;
UNLOCK TABLES;
```

### 间隙锁

对一个索引范围内的空隙进行锁定，不允许其他事务在这个范围内插入新数据。用于避免幻读问题。

```sql
BEGIN;
SELECT * FROM student WHERE age BETWEEN 20 AND 30 FOR UPDATE; # 在一个索引1范围1加锁，即间隙锁
```

### 意向锁

在以下场景中：

事务 A 加锁了 Users 表中的一行数据（行锁），事务 B 要对整个 Users 表进行加锁（表锁）， 如果事务 B 加锁成功的话，那么 B 是可以对表中的任意数据行进行操作的，包括事务 A 加锁的那行数据。这个时候就发生了锁冲突。

所以在这种情况下就需要意向锁。当事务 A 添加行锁的时候，先添加意向锁，而事务 B 在添加表锁的时候，先判断一下意向锁，如果有意向锁了，B 就不能加表锁了，这样就避免了锁冲突。

意向锁是 MySQL InnoDB 引擎中的一种锁机制（表级锁），用于协调事务间的加锁操作，以避免冲突和死锁的发生。

意向锁不需要开发者手动操作，而是由 InnoDB 存储引擎自己维护。

意向锁分为两种：

- 共享锁：允许多个事务同时持有锁，互不排斥，即读锁
- 排他锁：同一时间只能有一个事务持有锁，具有1互斥性和排他性，即写锁。

