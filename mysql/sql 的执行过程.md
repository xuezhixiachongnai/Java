# SQL 的执行顺序

一条 `SELECT` 的书写顺序

```sql
SELECT ...
FROM ...
WHERE ...
GROUP BY ...
HAVING ...
ORDER BY ...
LIMIT ...
```

但数据库在执行时，逻辑顺序大致是

1. FROM：确定数据源，执行表的连接、子查询
2. ON：处理连接条件
3. JOIN：执行表连接
4. WHERE ：过滤不符合条件的行
5. GROUP BY：按分组字段聚合
6. HAVING：过滤分组后的结果
7. SELECT：选择要返回的列或表达式
8. DISTINCT：去重
9. ORDER BY：排序
10. LIMIT / OFFSET：取出指定范围的结果

## MySQL 

mysql 的整体架构分层

```sh
   客户端驱动层
        │
  服务端层（Server）
        │
存储引擎层（Storage Engine）
```

我们的系统程序不是直接就能够和 MySQL 数据库进行通信的。是 MySQL 驱动在底层与数据库建立了连接，然后我们只需在客户端发送 SQL，执行 CRUD。

Java 系统在通过 MySQL 驱动与 MySQL 数据库连接的时候是基于 TCP/IP 协议的。在 web 系统中服务端通常都是并发处理请求，多个请求会创建多个来连接，使用完之后就会关闭。如果这样每个请求都是直接新建连接和销毁连接，势必会造成不必要的性能浪费。因此我们就需要数据库连接池来避免频繁的创建和销毁线程。

#### 数据库连接池

它会维护一定的连接数量，方便系统复用。常见的数据库连接池有：Druid、C3P0、DBCP

#### SQL 接口

数据库在连接线程中获取 SQL 语句之后，会交给 SQL 接口层处理

#### 查询解析器

然后查询解析器会将 SQL 接口中传递过来的 SQL 语句进行解析，翻译成 MySQL 能识别的语言

#### 查询优化器

查询优化器执行选出最优索引等步骤后，会去调用存储引擎接口，开始去执行被 MySQL 解析过和优化过的 SQL 语句

#### 执行器

最后执行器根据一系列的执行计划去调用存储引擎的接口去完成 SQL 的执行

### InnoDb

存储引擎的执行过程：

存储引擎会先去缓冲池去查找这条数据，没找到就会去磁盘中查找，如果查找到就会将这条数据加载到缓冲池中

> 因为直接从磁盘中加载太浪费时间

在加载到缓存的同时，会将这条数据的原始记录保存到 undo 日志文件中

存储引擎会在缓存中执行更新操作，同时数据会记录在 redo log buffer 中

> 如果这时数据库宕机了，更新后的数据就会丢失，这是会被认为事务失败，因为更新后的数据没有被写入磁盘，所以磁盘中的数据没有变化

当 redo log buffer 中的数据写入了 redo log 日志中时，认为一个事务完成，这是如果再宕机，也不会丢失数据，因为数据已经被写入 redo log 中了，MySQL 重启时会从中读取数据。

