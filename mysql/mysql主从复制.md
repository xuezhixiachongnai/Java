# MySQL 主从复制

## 开启主从复制

1. 配置主库

   修改配置文件（linux是`my.cnf` win是`my.ini`)

   ```ini
   [mysqld]
   server-id=1               # 唯一ID，主从不能重复
   log_bin=mysql-bin         # 开启二进制日志
   binlog_format=row         # 推荐使用 row 格式
   ```

   创建复制账号

   ```sql
   CREATE USER 'repl'@'%' IDENTIFIED BY 'repl_password'; # 创建复制账号
   GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%'; # 赋予复制权限
   FLUSH PRIVILEGES; # 刷新权限
   ```

   查看主库二进制日志位置

   ```sql
   SHOW MASTER STATUS;
   ```

   输出

   ```diff
   +------------------+----------+--------------+------------------+
   | File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
   +------------------+----------+--------------+------------------+
   | mysql-bin.000001 |     1546 |              |                  |
   +------------------+----------+--------------+------------------+
   ```

2. 配置从库

   修改配置文件

   ```ini
   [mysqld]
   server-id=2               # 从库唯一ID
   relay-log=relay-log-bin   # 中继日志
   ```

   设置复制源

   ```sql
   CHANGE MASTER TO
       MASTER_HOST='主库IP',
       MASTER_USER='repl',
       MASTER_PASSWORD='repl_password',
       MASTER_LOG_FILE='mysql-bin.000001',   -- 主库SHOW MASTER STATUS得到
       MASTER_LOG_POS=1546;                  -- 主库SHOW MASTER STATUS得到
   ```

   启动复制

   ```sql
   START SLAVE;
   ```

这样当在主库创建一个数据库之后，去从库查看是否已经复制到从库。

## 主从复制的作用和原理

主要作用：

- 数据备份与容灾：写入主库的数据会复制到从库备份，如果主库出现故障可以切换到从库，保证数据安全和业务的持续运行
- 主库负责写操作，从库负责读操作，实现负载均衡可以有效提高性能

原理：

MySQL 的主从复制主要是基于 log_bin（二进制日志）实现的。主库每接受到一个写操作，就会将这个操作记录到1二进制日志中，从库 IO 线程会自动连接主服务，从二进制日志中读取同步数据，记录到中继日志（relay-log-bin）中。从库的 SQL  线程会定期从中继日志中获取数据，写入数据库。

> Binary Log 二级制日志总共有三种模式：
>
> - STATEMENT 格式（语句模式，出现在 MySQL 5.1 之前）：在这种格式下，binlog 记录的是执行的 SQL 语句的文本
> - ROW 格式（行模式，诞生于 MySQL 5.1）：在这种格式下，binlog 记录的是每一行数据更改的具体内容
> - MIXED 格式（混合模式）：在这种格式下，binlog 可以根据具体的 SQL 语句和操作自动选择使用 STATEMENT 或 ROW 格式

## 一致性问题

从库向主库读取数据是异步过程，天然会有一些延迟和一致性问题

MySQL 提供了三种复制模式来平衡性能和一致性问题

#### 异步复制

默认的主从同步模式，主服务器提交事务后立即返回客户端，不会因为等待从服务器的写操作而被阻塞。因此有更高的吞吐量，但也有可能在数据库故障的情况下丢失数据

#### 同步复制

是一种最严格的复制模式，它要求主服务器提交一个事务之前。必须等待所有从服务器返回确认接收了数据之后才返回事务提交成功的消息。这样提供了更高的数据一致性，减少了数据丢失风险，但也会降低数据库吞吐性能

#### 半同步复制

半同步复制是一种折衷方案，它结合了异步复制的高性能和同步复制的高可靠性。在半同步复制模式下，主服务器在提交一个事务之前，需要等待至少一个从服务器确认接收到该事务的日志，但不需要等待从服务器完成应用。

## 分库分表

如果数据库，单表数据过多就需要进行分库分表

### 垂直拆分

1. 垂直分表

   也就是“大表拆小表”，基于列字段进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到“扩展表“。 一般是针对那种几百列的大表，也避免查询时，数据量太大造成的“跨页”问题。

2. 垂直分库

   垂直分库针对的是一个系统中的不同业务进行拆分，比如用户User一个库，商品Producet一个库，订单Order一个库。 切分后，要放在多个服务器上，而不是一个服务器上。为什么？ 我们想象一下，一个购物网站对外提供服务，会有用户，商品，订单等的CRUD。没拆分之前， 全部都是落到单一的库上的，这会让数据库的单库处理能力成为瓶颈。按垂直分库后，如果还是放在一个数据库服务器上， 随着用户量增大，这会让单个数据库的处理能力成为瓶颈，还有单个服务器的磁盘空间，内存，tps等非常吃紧。 所以我们要拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。

   数据库业务层面的拆分，和服务的“治理”，“降级”机制类似，也能对不同业务的数据分别的进行管理，维护，监控，扩展等。 数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于Web和应用服务器来讲，是比较难实现“横向扩展”的。 数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破IO、连接数及单机硬件资源的瓶颈。

### 水平拆分

1. 水平分表

   针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE,HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈。不建议采用。

2. 水平分库分表

   将单张表的数据切分到多个服务器上去，每个服务器具有相应的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。

3. 水平分库分表切分规则

   1. RANGE

      从0到10000一个表，10001到20000一个表；

   2. HASH取模

      一个商场系统，一般都是将用户，订单作为主表，然后将和它们相关的作为附表，这样不会造成跨库事务之类的问题。 取用户id，然后hash取模，分配到不同的数据库上。

   3. 地理区域

      比如按照华东，华南，华北这样来区分业务，七牛云应该就是如此。

   4. 时间

      按照时间切分，就是将6个月前，甚至一年前的数据切出去放到另外的一张表，因为随着时间流逝，这些表的数据 被查询的概率变小，所以没必要和“热数据”放在一起，这个也是“冷热数据分离”。

