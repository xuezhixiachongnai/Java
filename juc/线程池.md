# 线程池

线程池是一种管理和复用线程资源的机制，它由一个线程池管理器和一组工作线程组成。使用线程池的优点有：

- 复用线程，降低资源消耗。线程池不需要频繁的创建线程，它一般只在第一次提交线程任务时创建线程。在关闭线程池之前，创建的核心线程会存放在线程池中。
- 提高响应速度。线程池是复用已经创建好的线程，而线程需要一个新建的过程。
- 提供了管理线程数和任务的功能。通过初始化线程池参数，可以实现该功能。

## 线程池的使用

1. ThreadPoolExecutor

   阿里巴巴 Java 开发手册中推荐。使用这种方式，可以更加明确线程池的运行规则，规避资源耗尽的风险。

   > 该类初始化参数的含义
   >
   > ```java
   > // 核心参数
   > public class ThreadPoolExecutor {
   >     // 核心线程。被创建后长期存活的线程数。
   >     private int corePoolSize,
   >     // 最大线程数。线程池能管理的最大线程数。
   >     private int maximumPoolSize,
   >     // 空闲线程的存活时间。最大线程数-核心线程数=空闲线程
   >     private long keepAliveTime,
   >     // 存活时间的单位
   >     private TimeUnit unit,
   >     // 线程池任务队列。存放待执行任务的阻塞队列。
   >     private BlockingQueue<Runnable> workQueue,
   >     // 创建线程的工厂。线程池创建线程时调用的工厂方法。
   >     private ThreadFactory threadFactory,
   >     // 拒绝策略。当线程池的任务超出线程池队列可以存储的最大值之后，执行的策略。
   >     private RejectedExecutionHandler handler
   > }
   > ```

   ```java
   public static void main(String[] args) {
       int coreSize = 2;
       int maxSize = 4;
       long time = 1000;
       ThreadPoolExecutor executor = new ThreadPoolExecutor(coreSize, maxSize, time, 
                                                            TimeUnit.MICROSECONDS,
                                                            new ArrayBlockingQueue<>(10));
       for (int i = 0; i < 10; i++) {
           int finalI = i;
           executor.execute(() -> {
               System.out.println(finalI + " " + Thread.currentThread().getName());
           });
       }
       executor.shutdown();
   }
   ```

2. Executors

   使用该类创建线程池会比较方便。常用的ExecutorService的实现类有

   - FixedThreadPool：线程数固定的线程池；
   - CachedThreadPool：线程数根据任务动态调整的线程池；
   - SingleThreadExecutor：仅单线程执行的线程池。

   创建这些实现类的方法都被封装到了 Executors 类中

   ```java
   public static void main(String[] args) {
       // 创建一个固定大小的线程池:
       ExecutorService es = Executors.newFixedThreadPool(4);
       for (int i = 0; i < 6; i++) {
           es.submit(new Task("" + i));
       }
       // 关闭线程池:
       es.shutdown();
   }
   ```

3. ThreadPoolTaskExecutor

   在Spring 项目中，会使用代码可读性更高的 ThreadPoolTaskExecutor 来创建线程池，它的底层也是通过 ThreadPoolExecutor 来实现的

   ```java
   @Configuration
   public class ThreadPoolConfig {
   
       @Bean
       public ThreadPoolTaskExecutor threadPoolExecutor() {
           ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
           // 核心线程数
           executor.setCorePoolSize(5);
           // 最大线程数
           executor.setMaxPoolSize(10);
           // 队列容量
           executor.setQueueCapacity(20);
           // 线程池维护线程所允许的空闲时间
           executor.setKeepAliveSeconds(60);
           // 线程池对拒绝任务（无线程可用）的处理策略
           executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
           // 初始化，否则线程池参数不会生效（Spring Boot 自动配置时会自动调用）
           executor.initialize();
           return executor;
       }
   }
   ```

   ## 如果遇到异常
   
   线程池通过 `execute`和`submit`方法提交任务执行程序，在程序执行过程中如果遇到未处理的异常两者的效果如下：
   
   1. `execute`方法接受一个 `Runnable`类型的参数，不返回任何结果。当程序执行过程中遇到未处理的异常，会直接抛出，并将当前线程销毁。
   
   2. `submit`方法接收一个 Callable 或 Runnable 类型的参数，并返回一个`Future`对象，通过该对象可以获取任务的执行结果或检查任务的状态。当程序执行过程中遇到未处理的异常，会将异常封装在`Future`中，可以通过`get`方法获取。不会直接影响执行任务的线程，线程可以继续复用。
   
      ```java
      Future<?> future = executor.submit(() -> {
          if (new Random().nextInt() > 0.5) {
              throw new RuntimeException("抛出异常");
          }
          String tName = Thread.currentThread().getName();
          System.out.println("线程名：" + tName);
      });
      try {
          future.get();
      } catch (Exception e) {
          System.out.println("遇到异常："+e.getMessage());
      }
      ```
   
      