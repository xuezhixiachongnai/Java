# 如何排查死锁

**什么是死锁**

两个线程相互持有对方要获得的锁，导致两个线程之间无限等待。

死锁只有同时满足以下四个条件才会发生：

- 互斥条件：资源不能同时被多个线程使用
- 持有并等待：线程 A 持有了一个锁，但在获取其他锁的过程中不会释放自己原本持有的锁
- 不可剥夺条件：只能等线程主动释放锁，在此之前其他线程不能获取该锁
- 环路等待：指两个线程获取资源的顺序构成了环形链

**死锁的实例代码**

```java
public class Demo {
    
    public static void main(String[] args) throws InterruptedException {
        Thread th1 = new Thread(() -> {
            synchronized (Counter.incLock) {
                Counter.inc();
                System.out.println(Thread.currentThread().getName() + " " + "获取了incLock锁");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    
                }
                synchronized (Counter.decLock) {
                    Counter.dec();
                }
            }
        });
        Thread th2 = new Thread(() -> {
            synchronized (Counter.decLock) {
                System.out.println(Thread.currentThread().getName() + " " + "获取了decLock锁");
                Counter.dec();
                synchronized (Counter.incLock) {
                    Counter.inc();
                }
            }
        });
        th1.start();
        th2.start();
        th1.join();
        th2.join();
        System.out.println("main end");
    }
}

class Counter {

    public static Object incLock = new Object();
    public static Object decLock = new Object();

    private static Integer count = 0;

    public static void inc() {
        count++;
    }

    public static void dec() {
        count--;
    }

    public static Integer getCount() {
        return count;
    }
}
```

这样就实现了死锁

**排查死锁**

运行上面的代码

**通过 JDK 工具 jps、jstack 排查死锁**

> jps 是 JDK 提供用于查看正在运行的 Java 进程
>
> jstack 是 JDK 提供用于查看 Java 进程中线程堆栈信息

```sh
PS D:\Project\IdeaProjects\java> jps -l # 查看 Java 进程
36912 Demo
PS D:\Project\IdeaProjects\java> jstack 36912 # 查看死锁
Found one Java-level deadlock:
=============================
"Thread-0":
  waiting to lock monitor 0x000002294756a770 (object 0x0000000715671560, a java.lang.Object),
  which is held by "Thread-1"

"Thread-1":
  waiting to lock monitor 0x000002294756a230 (object 0x0000000715671550, a java.lang.Object),
  which is held by "Thread-0"

Java stack information for the threads listed above:
===================================================
"Thread-0":
        at Demo.lambda$main$0(Demo.java:14)
        - waiting to lock <0x0000000715671560> (a java.lang.Object)
        - locked <0x0000000715671550> (a java.lang.Object)
        at Demo$$Lambda$1/0x0000022949000a00.run(Unknown Source)
        at java.lang.Thread.run(java.base@17.0.15/Thread.java:840)
"Thread-1":
        at Demo.lambda$main$1(Demo.java:23)
        - waiting to lock <0x0000000715671550> (a java.lang.Object)
        - locked <0x0000000715671560> (a java.lang.Object)
        at Demo$$Lambda$2/0x0000022949000c18.run(Unknown Source)
        at java.lang.Thread.run(java.base@17.0.15/Thread.java:840)

Found 1 deadlock.
```

**通过 JDK 提供的 jconsole 排查死锁**

> 它是一个可视化的工具，方便排查程序的一些问题，如：程序内存溢出、死锁问题等

```sh
PS D:\Project\IdeaProjects\java> jconsole # 命令行启动该程序
```

**使用 JDK 提供的 VisualVM 排查死锁**

**如何有效避免死锁**

- 加锁顺序统一

- 使用 tryLock

- 缩小锁范围

- 用并发工具类代替手写锁

- 监控死锁

## 排查 CPU 飙升 100% 问题

原因可能是：

- 内存消耗过大，导致 Full GC 次数过多
- 代码中有大量消耗 CPU 的操作，导致 CPU 占用过高
- 出现死锁

排查步骤:

```sh
top # 查看所有进程占系统 CPU 的排序
top -Hp 进程号 # 查看 Java 进程下的所有线程占 CPU 情况
jstack 进程号 # 排查堆栈信息
# 查看 GC 情况
```

